{"name":"Mercury-hsx-reader","tagline":"A MSX reader for JavaScript, powered by sweet.js.","body":"### Welcome to Mercury HSX Reader\r\n\r\nCompile your templates into Mercury compatible HSX virtual DOM DSL\r\n\r\n```html\r\n  <:MyCool />\r\n  <SideBySideEditor />\r\n  <MyEditor state=\"sideBySideEditor\"/>\r\n\r\n  <div>\r\n    <:SideBySideEditor />\r\n  </div>\r\n\r\n  <header>\r\n    <section name=\"main\">\r\n      <h2>my title</h2>\r\n      <p>some text here</p>\r\n    <section>\r\n  </header>\r\n```\r\n\r\nWhen compiled the markup is turned into mercury compatible (nested) `h` calls which creates a virtual dom.\r\n\r\n```js\r\nthis.renderComponent('MyCool', null)\r\nthis.renderComponent('SideBySideEditor', null)\r\nthis.renderComponent('MyEditor', { state: 'sideBySideEditor' })\r\nh('div', null, [this.renderComponent('SideBySideEditor', null)])\r\n\r\nh('header', null, \r\n  [h('section', { name: 'main' }, \r\n    [h('h2', null, \r\n       ['my title']), \r\n     h('p', null, \r\n       ['some text here']) \r\n    ])\r\n   ]\r\n)\r\n```\r\n\r\nNotice that currently, your render context is expected to contain a function `renderComponent` which is called with arguments that identify the component and arguments. It then has the responsibility to find the component and call it as per your conventions.\r\n\r\nTo mark a tag as a component call, either:\r\n\r\n- prefix its name with a `:` \r\n- capitalize the tag name\r\n\r\nExamples: `<MyEditor state=\"sideBySideEditor\"/>` and `<:SideBySideEditor />`\r\n\r\n### Running tests\r\n\r\n`node hsx-tests.js`\r\n\r\n### License\r\n\r\nEnjoy :)\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}